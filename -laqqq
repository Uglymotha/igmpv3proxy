[1mdiff --git a/src/cli.c b/src/cli.c[m
[1mindex 1fe1ac5..891dcd2 100644[m
[1m--- a/src/cli.c[m
[1m+++ b/src/cli.c[m
[36m@@ -133,7 +133,7 @@[m [mvoid cliCmd(char *cmd) {[m
     struct sigaction   sa;[m
     struct stat        st;[m
     struct sockaddr_un srv_sa;[m
[31m-    char               buf[CLI_CMD_BUF+1] = "", paths[sizeof(CLI_SOCK_PATHS)] = CLI_SOCK_PATHS, *path, tpath[50];[m
[32m+[m[32m    char               buf[CLI_CMD_BUF+1] = "", paths[sizeof(CLI_SOCK_PATHS)] = CLI_SOCK_PATHS, *path, tpath[128];[m
 [m
     sa.sa_handler = signalHandler;[m
     sa.sa_flags = 0;    /* Interrupt system calls */[m
[36m@@ -149,9 +149,14 @@[m [mvoid cliCmd(char *cmd) {[m
     srv_sa.sun_len = SUN_LEN(&srv_sa);[m
 #endif[m
 [m
[31m-    // Check for daemon socket.[m
[32m+[m[32m    // Check for daemon socket location.[m
     path = strtok(paths, " ");[m
     while (path) {[m
[32m+[m[32m        sprintf(tpath, "%s/%s/root", path, fileName);[m
[32m+[m[32m        if (lstat(tpath, &st) == 0 && S_ISLNK(st.st_mode)) {[m
[32m+[m[32m            strcpy(srv_sa.sun_path, strcat(tpath, "/cli.sock"));[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
         sprintf(tpath, "%s/%s/cli.sock", path, fileName);[m
         if (stat(tpath, &st) != -1) {[m
             strcpy(srv_sa.sun_path, tpath);[m
[36m@@ -173,8 +178,7 @@[m [mvoid cliCmd(char *cmd) {[m
     }[m
 [m
     // Receive the daemon's answer. It will be closed by one single byte.[m
[31m-    for (int len = recv(srv_fd, &buf, CLI_CMD_BUF, 0); len > 0; memset(buf, 0, len), len = recv(srv_fd, &buf, CLI_CMD_BUF, 0))[m
[31m-        fprintf(stdout, "%s", buf);[m
[32m+[m[32m    for (int len = 0; (len = recv(srv_fd, &buf, CLI_CMD_BUF, 0)) > 0; buf[len] = 0, fprintf(stdout, "%s", buf));[m
 [m
     close(srv_fd);[m
 }[m
[1mdiff --git a/src/igmp.c b/src/igmp.c[m
[1mindex c456f3e..dc8ace5 100644[m
[1m--- a/src/igmp.c[m
[1m+++ b/src/igmp.c[m
[36m@@ -111,8 +111,9 @@[m [mstatic bool checkIgmp(struct IfDesc *IfDp, register uint32_t src, register uint3[m
     else if ((IfDp->state & ifstate) == 0) {[m
         strcat(strcpy(msg, ""), IS_UPSTREAM(IfDp->state)   ? "upstream interface "[m
                               : IS_DOWNSTREAM(IfDp->state) ? "downstream interface " : "disabled interface ");[m
[31m-        LOG(LOG_INFO, 0, "checkIgmp: Message for %s from %s was received on %s. Ignoring.",[m
[31m-                          inetFmt(group, 1), inetFmt(src, 2), strcat(msg, IfDp->Name));[m
[32m+[m[32m        LOG(LOG_INFO, 0, "checkIgmp: Message for %s from %s was received on %s interface %s. Ignoring.",[m
[32m+[m[32m                          inetFmt(group, 1), inetFmt(src, 2), IS_UPSTREAM(IfDp->state) ? "upstream"[m
[32m+[m[32m                          : IS_DOWNSTREAM(IfDp->state) ? "downstream" : "disabled", IfDp->Name);[m
     } else[m
         return true;[m
 [m
[36m@@ -189,7 +190,7 @@[m [mvoid acceptIgmp(int recvlen, struct msghdr msgHdr) {[m
     else if (IfDp->conf->cksumVerify && cksum != inetChksum((uint16_t *)igmp, ipdatalen))[m
         LOG(LOG_NOTICE, 0, "acceptIgmp: Received packet from: %s for: %s on: %s checksum incorrect.",[m
                              inetFmt(src, 1), inetFmt(dst, 2), IfDp->Name);[m
[31m-    else if (checkIgmp(IfDp, src, htonl(0xE0FFFFFF), IF_STATE_DOWNSTREAM)) {[m
[32m+[m[32m    else {[m
         struct igmpv3_query  *igmpv3   = (struct igmpv3_query *)(recv_buf + iphdrlen);[m
         struct igmpv3_report *igmpv3gr = (struct igmpv3_report *)(recv_buf + iphdrlen);[m
         struct igmpv3_grec   *grec     = &igmpv3gr->igmp_grec[0];[m
[36m@@ -220,7 +221,7 @@[m [mvoid acceptIgmp(int recvlen, struct msghdr msgHdr) {[m
         }[m
 [m
         case IGMP_MEMBERSHIP_QUERY:[m
[31m-            if (IN_MULTICAST(ntohl(dst)) && IfDp->conf->qry.election && !IS_DISABLED(IfDp->state))[m
[32m+[m[32m            if (IfDp->conf->qry.election && checkIgmp(IfDp, src, htonl(0xE0FFFFFF), IF_STATE_UPDOWNSTREAM))[m
                 acceptMemberQuery(IfDp, src, dst, igmpv3, ipdatalen);[m
             return;[m
 [m
[1mdiff --git a/src/igmpv3proxy.c b/src/igmpv3proxy.c[m
[1mindex d610dac..d3b8826 100644[m
[1m--- a/src/igmpv3proxy.c[m
[1m+++ b/src/igmpv3proxy.c[m
[36m@@ -62,7 +62,7 @@[m [mstatic char          *recv_buf;[m
 */[m
 int main(int ArgCn, char *ArgVc[]) {[m
     int          c = 0, i = 0, j = 0;[m
[31m-    char        *opts[2] = { NULL, NULL }, cmd[20] = "",[m
[32m+[m[32m    char        *opts[2] = { ArgVc[0], NULL }, cmd[20] = "",[m
                  paths[sizeof(CFG_PATHS) + 1] = CFG_PATHS, *path = NULL, *file;[m
     struct stat  st;[m
     fileName = basename(ArgVc[0]);[m
[36m@@ -72,6 +72,7 @@[m [mint main(int ArgCn, char *ArgVc[]) {[m
     openlog(fileName, LOG_PID, LOG_DAEMON);[m
     CONFIG->logLevel = LOG_WARNING;[m
     srand(time(NULL) * getpid());[m
[32m+[m[32m    CONFIG->hashSeed = ((uint32_t)rand() << 16) | (uint32_t)rand();[m
 [m
     // Parse the commandline options and setup basic settings..[m
     for (c = getopt(ArgCn, ArgVc, "cvVdnh"); c != -1; c = getopt(ArgCn, ArgVc, "cvVdnh")) {[m
[36m@@ -99,6 +100,8 @@[m [mint main(int ArgCn, char *ArgVc[]) {[m
                     cmd[0] = c;[m
                     if (c != 'r' && (h = getopt(j ? 2 : ArgCn, j ? opts : ArgVc, "cbr::ifth")) == 'h')[m
                         strcat(cmd, "h");[m
[32m+[m[32m                    else if (h == '?')[m
[32m+[m[32m                        break;[m
                     else if (c == 'r' && optarg) {[m
                         if (optarg[0] == 'h') {[m
                             strcat(cmd, "h");[m
[36m@@ -108,7 +111,8 @@[m [mint main(int ArgCn, char *ArgVc[]) {[m
                         if (strlen(optarg) > 0) {[m
                             if (!parseSubnetAddress(optarg, &addr, &mask)) {[m
                                 i = optind, j = optind = 1;[m
[31m-                                opts[1] = malloc(strlen(optarg) + 1);[m
[32m+[m[32m                                if (! (opts[1] = malloc(strlen(optarg) + 1)))[m
[32m+[m[32m                                    exit(-1);[m
                                 sprintf(opts[1], "-%s", optarg);[m
                             } else if (!IN_MULTICAST(ntohl(addr))) {[m
                                 fprintf(stdout, "Ignoring %s, not a valid multicast address.\n", optarg);[m
[36m@@ -119,11 +123,10 @@[m [mint main(int ArgCn, char *ArgVc[]) {[m
                     cliCmd(cmd);[m
                     break;[m
                 }[m
[31m-                if (j) {[m
[31m-                    c = c == 'r' || h == 'h' ? getopt(2, opts, "cbr::ift") : h;[m
[31m-                } else if (h == 'h' || c == 'r')[m
[31m-                    c = getopt(ArgCn, ArgVc, "cbr::ift");[m
[32m+[m[32m                if (h == 'h' || c == 'r')[m
[32m+[m[32m                    c = getopt(j ? 2 : ArgCn, j ? opts : ArgVc, "cbr::ift");[m
                 else if (c == -1 && j == 1) {[m
[32m+[m[32m                    free(opts[1]);[m
                     optind = i, j = 0;[m
                     c = getopt(ArgCn, ArgVc, "cbr::ift");[m
                 } else[m
[36m@@ -195,15 +198,12 @@[m [mint main(int ArgCn, char *ArgVc[]) {[m
 *   Handles the initial startup of the daemon.[m
 */[m
 static void igmpProxyInit(void) {[m
[31m-    char             tS[32] = "";[m
     struct sigaction sa;[m
     sigstatus = 1;  // STARTUP[m
 [m
     umask(S_IROTH | S_IWOTH | S_IXOTH);[m
     clock_gettime(CLOCK_REALTIME, &starttime);[m
[31m-    strcpy(tS, asctime(localtime(&starttime.tv_sec)));[m
[31m-    tS[strlen(tS) - 1] = '\0';[m
[31m-    LOG(LOG_WARNING, 0, "Initializing IGMPv3 Proxy on %s.", tS);[m
[32m+[m[32m    LOG(LOG_WARNING, 0, "Initializing IGMPv3 Proxy on %s.", asctime(localtime(&starttime.tv_sec)));[m
 [m
     sa.sa_handler = signalHandler;[m
     sa.sa_flags = 0;                // Interrupt system calls[m
[36m@@ -220,7 +220,6 @@[m [mstatic void igmpProxyInit(void) {[m
     if (!loadConfig(CONFIG->configFilePath))[m
         LOG(LOG_ERR, 0, "Failed to load configuration from '%s'.", CONFIG->configFilePath);[m
     LOG(LOG_WARNING, 0, "Loaded configuration from '%s'. Starting IGMPv3 Proxy.", CONFIG->configFilePath);[m
[31m-    CONFIG->hashSeed = ((uint32_t)rand() << 16) | (uint32_t)rand();[m
 [m
     // If no socket group was configured set it to configured users's group or root.[m
     if (! CONFIG->group && ! (CONFIG->group = getgrgid(CONFIG->user ? CONFIG->user->pw_gid : 0)))[m
[36m@@ -232,7 +231,7 @@[m [mstatic void igmpProxyInit(void) {[m
     struct stat st;[m
     for (path = strtok(paths, " "); path; path = strtok(NULL, " ")) {[m
         if (stat(path, &st) != -1) {[m
[31m-            if (! (CONFIG->runPath = malloc(strlen(path) + strlen(fileName) + 3)))[m
[32m+[m[32m            if (! (CONFIG->runPath = malloc(strlen(path) + strlen(fileName) + 8)))[m
                 LOG(LOG_ERR, 0, "Out of memory.");   // Freed by igmpProxyCleanup()[m
             sprintf(CONFIG->runPath, "%s/%s/", path, fileName);[m
             break;[m
[36m@@ -242,33 +241,23 @@[m [mstatic void igmpProxyInit(void) {[m
         || chown(CONFIG->runPath, uid, gid) || chmod (CONFIG->runPath, 01770))[m
         LOG(LOG_ERR, errno, "Failed to create run ndirectory %s.", CONFIG->runPath);[m
 [m
[31m-    // Write PID.[m
[31m-    char  pidFile[strlen(CONFIG->runPath) + strlen(fileName) + 5];[m
[31m-    sprintf(pidFile, "%s/%s.pid", CONFIG->runPath, fileName);[m
[31m-    remove(pidFile);[m
[31m-    FILE *pidFilePtr = fopen(pidFile, "w");[m
[31m-    fprintf(pidFilePtr, "%d\n", getpid());[m
[31m-    fclose(pidFilePtr);[m
[31m-[m
[31m-    // Enable mroute while still running as root.[m
[31m-    pollFD[0] = (struct pollfd){ k_enableMRouter(), POLLIN, 0 };[m
[31m-    // Open CLI Socket[m
[31m-    pollFD[1] = (struct pollfd){ openCliFd(), POLLIN, 0 };[m
[31m-[m
     // Switch root if chroot is configured.[m
     if (CONFIG->chroot) {[m
         char *p = CONFIG->configFilePath, *b = basename(CONFIG->configFilePath);[m
         LOG(LOG_WARNING, 0, "Switching root to %s.", CONFIG->chroot);[m
 [m
[32m+[m[32m        // Link the root to the run directory and set runpath to /..[m
[32m+[m[32m        remove(strcat(CONFIG->runPath, "root"));[m
[32m+[m[32m        if (symlink(CONFIG->chroot, CONFIG->runPath) != 0)[m
[32m+[m[32m            LOG(LOG_ERR, errno, "Failed to link chroot directory %s to run directory %s.", CONFIG->chroot, CONFIG->runPath);[m
[32m+[m[32m        strcpy(CONFIG->runPath, "/");[m
[32m+[m
         // Truncate config file path.[m
         if (! (CONFIG->configFilePath = malloc(strlen(b) + 1)))[m
             LOG(LOG_ERR, 0, "Out of Memory");[m
         strcpy(CONFIG->configFilePath, b);[m
         free(p);    // Alloced by main()[m
 [m
[31m-        if (!(stat(CONFIG->chroot, &st) == 0 && chmod(CONFIG->chroot, 0770) == 0 && chroot(CONFIG->chroot) == 0 && chdir("/") == 0))[m
[31m-            LOG(LOG_ERR, errno, "Failed to switch root to %s.",CONFIG->chroot);[m
[31m-[m
         // Truncate log file path if congigured.[m
         if (CONFIG->logFilePath) {[m
             p = CONFIG->logFilePath, b = basename(CONFIG->logFilePath);[m
[36m@@ -277,8 +266,25 @@[m [mstatic void igmpProxyInit(void) {[m
             strcpy(CONFIG->logFilePath, b);[m
             free(p);    // Alloced by loadConfig()[m
         }[m
[32m+[m
[32m+[m[32m        // Swith root directory.[m
[32m+[m[32m        if (!(stat(CONFIG->chroot, &st) == 0 && chmod(CONFIG->chroot, 0770) == 0 && chroot(CONFIG->chroot) == 0 && chdir("/") == 0))[m
[32m+[m[32m            LOG(LOG_ERR, errno, "Failed to switch root to %s.",CONFIG->chroot);[m
     }[m
 [m
[32m+[m[32m    // Write PID.[m
[32m+[m[32m    char  pidFile[strlen(CONFIG->runPath) + strlen(fileName) + 5];[m
[32m+[m[32m    sprintf(pidFile, "%s/%s.pid", CONFIG->runPath, fileName);[m
[32m+[m[32m    remove(pidFile);[m
[32m+[m[32m    FILE *pidFilePtr = fopen(pidFile, "w");[m
[32m+[m[32m    fprintf(pidFilePtr, "%d\n", getpid());[m
[32m+[m[32m    fclose(pidFilePtr);[m
[32m+[m
[32m+[m[32m    // Enable mroute while still running as root.[m
[32m+[m[32m    pollFD[0] = (struct pollfd){ k_enableMRouter(), POLLIN, 0 };[m
[32m+[m[32m    // Open CLI Socket[m
[32m+[m[32m    pollFD[1] = (struct pollfd){ openCliFd(), POLLIN, 0 };[m
[32m+[m
     // Make sure logfile and chroot directoryis owned by configured user and switch ids.[m
     if (CONFIG->user) {[m
         LOG(LOG_WARNING, 0, "Switching user to %s.", CONFIG->user->pw_name);[m
[1mdiff --git a/src/kern.c b/src/kern.c[m
[1mindex c1ec796..fb2ab59 100644[m
[1m--- a/src/kern.c[m
[1m+++ b/src/kern.c[m
[36m@@ -156,7 +156,7 @@[m [minline int k_setSourceFilter(struct IfDesc *IfDp, uint32_t group, uint32_t fmode[m
         *(struct sockaddr_in *)(ss + i) = (struct sockaddr_in){ AF_INET, 0, {slist[i]}, {0} };[m
 #endif[m
     LOG(LOG_INFO, 0, "setSourceFilter: Setting source filter on %s for %s (%s) with %d sources.", IfDp->Name, inetFmt(group, 1),[m
[31m-                     fmode ? "IN" : "EX", nsrcs);[m
[32m+[m[32m                      fmode ? "IN" : "EX", nsrcs);[m
     if (setsourcefilter(mrouterFD, if_nametoindex(IfDp->Name), (struct sockaddr *)&sin, sizeof(struct sockaddr_in),[m
                         fmode, nsrcs, ss) < 0 && ((err = errno) != er || nsrcs == 0))[m
         LOG(LOG_WARNING, err, "Failed to update source filter list for %s on %s.", inetFmt(group, 1), IfDp->Name);[m
[1mdiff --git a/src/querier.c b/src/querier.c[m
[1mindex 946618b..816f758 100644[m
[1m--- a/src/querier.c[m
[1m+++ b/src/querier.c[m
[36m@@ -289,7 +289,7 @@[m [mvoid groupSpecificQuery(struct qlst *qlst) {[m
 [m
     free(query1);  // Alloced by self.[m
     free(query2);  // Alloced by self.[m
[31m-    logRouteTable("Activate Route", 1, -1, group, (uint32_t)-1);[m
[32m+[m[32m    logRouteTable("GSQ", 1, -1, group, (uint32_t)-1);[m
 }[m
 [m
 /**[m
